# 回溯算法

## 回溯算法的本质

决策树的遍历过程

## 需要思考的三个问题

1. 路径：已经做出的选择

2. 选择列表：当前可以做的选择

3. 结束条件：到达决策树底层，无法再做选择

## 算法框架

```python
  result = []

  def backtrace(路径，选择列表):
    if 满足结束条件:
      result.add(路径)
      return

    for 选择 in 选择列表:
      做选择
      backtrace(路径，选择列表)
      撤销选择
```

_核心_：循环当中的递归，在递归之前【做选择】在递归调用之后【撤销选择】，只需要在递归之前作出选择，递归之后撤销刚才的选择

## 典型例子

- 全排列问题
- N 皇后问题
- 解数独

## 时间复杂度分析

回溯算法不管如何优化，时间复杂度都不可避免的低于 O(N!)，因为穷举整颗决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可优化，回溯属于纯暴力穷举，复杂度一般都很高

## 总结

回溯算法就是多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作。算法框架如下：

```
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```

写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。
